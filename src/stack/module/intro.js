
/**
 * 模块化的发展之路
 * 0.直接定义依赖，大量的全局变量，可能会引起变量冲突
 * 1.命名空间：将需要定义的部分归属到一个对象的属性上
 * 2.闭包 自执行:形成独立的作用域，该变量私有
 * 开始出现异步机制
 * 3.require.js AMD：依赖前置
 * 4.sea.js CMD：用到时才运行
 * 5.node.js common.js：require()运行时才加载，且是将整个模块作为一个对象引入，然后再从这个对象上获取属性
 * 6.es6 es module:编译时就能确定模块的依赖关系，以及其输入和输出的变量
 */   